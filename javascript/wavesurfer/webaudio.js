// Generated by CoffeeScript 1.3.3
(function() {

  define(function(require) {
    var WebAudio, exports;
    WebAudio = {
      Defaults: {
        fftSize: 1024,
        smoothingTimeConstant: 0.3
      },
      ac: new (window.AudioContext || window.webkitAudioContext),
      init: function(params) {
        params = params || {};
        this.fftSize = params.fftSize || this.Defaults.fftSize;
        this.destination = params.destination || this.ac.destination;
        this.analyser = this.ac.createAnalyser();
        this.analyser.smoothingTimeConstant = params.smoothingTimeConstant || this.Defaults.smoothingTimeConstant;
        this.analyser.fftSize = this.fftSize;
        this.analyser.connect(this.destination);
        this.proc = this.ac.createJavaScriptNode(this.fftSize / 2, 1, 1);
        this.proc.connect(this.destination);
        this.dataArray = new Uint8Array(this.analyser.fftSize);
        return this.paused = true;
      },
      setSource: function(source) {
        this.source && this.source.disconnect();
        this.source = source;
        this.source.connect(this.analyser);
        return this.source.connect(this.proc);
      },
      loadData: function(audioData, cb) {
        var self;
        self = this;
        return this.ac.decodeAudioData(audioData, (function(buffer) {
          self.currentBuffer = buffer;
          self.lastPause = 0;
          self.lastPlay = 0;
          return cb(buffer);
        }), Error);
      },
      getDuration: function() {
        return this.currentBuffer && this.currentBuffer.duration;
      },
      play: function(start, end, delay) {
        if (!this.currentBuffer) {
          return;
        }
        this.pause();
        this.setSource(this.ac.createBufferSource());
        this.source.buffer = this.currentBuffer;
        start = start || this.lastPause;
        end = end || this.source.buffer.duration;
        delay = delay || 0;
        this.lastPlay = this.ac.currentTime;
        this.source.noteGrainOn(delay, start, end - start);
        return this.paused = false;
      },
      pause: function(delay) {
        if (!this.currentBuffer || this.paused) {
          return;
        }
        this.lastPause += this.ac.currentTime - this.lastPlay;
        this.source.noteOff(delay || 0);
        return this.paused = true;
      },
      waveform: function() {
        this.analyser.getByteTimeDomainData(this.dataArray);
        return this.dataArray;
      },
      frequency: function() {
        this.analyser.getByteFrequencyData(this.dataArray);
        return this.dataArray;
      }
    };
    return exports = WebAudio;
  });

}).call(this);
