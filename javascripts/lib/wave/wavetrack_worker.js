// Generated by CoffeeScript 1.3.3
(function() {
  var BinaryWriter, WaveTrack,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BinaryWriter = (function() {

    function BinaryWriter(estimatedSize) {
      this.writeInteger = __bind(this.writeInteger, this);

      this.writeString = __bind(this.writeString, this);

      this.writeInt32 = __bind(this.writeInt32, this);

      this.writeUInt32 = __bind(this.writeUInt32, this);

      this.writeInt16 = __bind(this.writeInt16, this);

      this.writeUInt16 = __bind(this.writeUInt16, this);

      this.writeInt8 = __bind(this.writeInt8, this);

      this.writeUInt8 = __bind(this.writeUInt8, this);
      this.estimatedSize = estimatedSize;
      this.pos = 0;
      this.data = new Uint8Array(estimatedSize);
      this.masks = [0x0, 0xFF + 1, 0xFFFF + 1, 0xFFFFFF + 1, 0xFFFFFFFF + 1];
    }

    BinaryWriter.prototype.writeUInt8 = function(value, bigEndian) {
      return this.writeInteger(value, 1, bigEndian);
    };

    BinaryWriter.prototype.writeInt8 = function(value, bigEndian) {
      return this.writeInteger(value, 1, bigEndian);
    };

    BinaryWriter.prototype.writeUInt16 = function(value, bigEndian) {
      return this.writeInteger(value, 2, bigEndian);
    };

    BinaryWriter.prototype.writeInt16 = function(value, bigEndian) {
      return this.writeInteger(value, 2, bigEndian);
    };

    BinaryWriter.prototype.writeUInt32 = function(value, bigEndian) {
      return this.writeInteger(value, 4, bigEndian);
    };

    BinaryWriter.prototype.writeInt32 = function(value, bigEndian) {
      return this.writeInteger(value, 4, bigEndian);
    };

    BinaryWriter.prototype.writeString = function(value) {
      var i, _results;
      i = 0;
      i = 0;
      _results = [];
      while (i < value.length) {
        this.data[this.pos++] = value.charCodeAt(i);
        _results.push(++i);
      }
      return _results;
    };

    BinaryWriter.prototype.writeInteger = function(value, size, bigEndian) {
      var i, r, _results;
      r = value;
      i = 0;
      if (value < 0) {
        r += this.masks[size];
      }
      i = 0;
      _results = [];
      while (i < size) {
        if (bigEndian === true) {
          this.data[this.pos++] = (r >> ((size - i - 1) * 8)) & 0xFF;
        } else {
          this.data[this.pos++] = (r >> (i * 8)) & 0xFF;
        }
        _results.push(++i);
      }
      return _results;
    };

    return BinaryWriter;

  })();

  WaveTrack = (function() {
    var convertFloatToInt, convertIntToFloat;

    function WaveTrack() {}

    convertIntToFloat = function(value, waveBitsPerSample, signedBorder) {
      if (waveBitsPerSample === 8) {
        if (value === 0) {
          return -1.0;
        } else {
          return value / signedBorder - 1.0;
        }
      } else {
        if (value === 0) {
          return 0;
        } else {
          return value / signedBorder;
        }
      }
    };

    convertFloatToInt = function(value, waveBitsPerSample, signedBorder) {
      if (waveBitsPerSample === 8) {
        return (value + 1.0) * signedBorder;
      } else {
        return value * signedBorder;
      }
    };

    WaveTrack.prototype.sampleRate = 0;

    WaveTrack.prototype.audioSequences = [];

    WaveTrack.prototype.signedBorders = [0, 0xFF - 0x80, 0xFFFF - 0x8000, 0xFFFFFFFFF - 0x80000000];

    WaveTrack.prototype.fromAudioSequences = function(sequences) {
      var i, lengthCheck, sampleRateCheck;
      if (sequences.length === 0) {
        return;
      }
      sampleRateCheck = sequences.sampleRate;
      lengthCheck = sequences.data.length;
      i = 1;
      while (i < sequences.length) {
        if (sequences[i].sampleRate !== sampleRateCheck || sequences[i].data.length !== lengthCheck) {
          throw "The input sequences must have the same length and samplerate";
        }
        ++i;
      }
      this.sampleRate = sampleRateCheck;
      this.audioSequences.push(sequences);
      return null;
    };

    WaveTrack.prototype.encodeWaveFile = function() {
      var channelId, i, signBorderId, signedBorder, totalSize, waveAudioFormat, waveBitsPerSample, waveBlockAlign, waveByteRate, waveChunkID, waveChunkSize, waveFormat, waveNumChannels, waveSampleRate, waveSamplesPerChannel, waveSubchunk1ID, waveSubchunk1Size, waveSubchunk2ID, waveSubchunk2Size, writer;
      waveChunkID = "RIFF";
      waveFormat = "WAVE";
      waveSubchunk1ID = "fmt ";
      waveSubchunk1Size = 16;
      waveAudioFormat = 1;
      waveNumChannels = this.audioSequences.length;
      waveSampleRate = this.sampleRate;
      waveBitsPerSample = 16;
      waveByteRate = waveSampleRate * waveNumChannels * waveBitsPerSample / 8;
      waveBlockAlign = waveNumChannels * waveBitsPerSample / 8;
      waveBitsPerSample = 16;
      waveSamplesPerChannel = this.audioSequences[0].data.length;
      waveSubchunk2ID = "data";
      waveSubchunk2Size = waveSamplesPerChannel * waveBlockAlign;
      waveChunkSize = waveSubchunk2Size + 36;
      totalSize = waveChunkSize + 8;
      writer = new BinaryWriter(totalSize);
      writer.writeString(waveChunkID);
      writer.writeUInt32(waveChunkSize);
      writer.writeString(waveFormat);
      writer.writeString(waveSubchunk1ID);
      writer.writeUInt32(waveSubchunk1Size);
      writer.writeUInt16(waveAudioFormat);
      writer.writeUInt16(waveNumChannels);
      writer.writeUInt32(waveSampleRate);
      writer.writeUInt32(waveByteRate);
      writer.writeUInt16(waveBlockAlign);
      writer.writeUInt16(waveBitsPerSample);
      writer.writeString(waveSubchunk2ID);
      writer.writeUInt32(waveSubchunk2Size);
      signBorderId = waveBitsPerSample / 8;
      signedBorder = this.signedBorders[signBorderId];
      i = 0;
      while (i < waveSamplesPerChannel) {
        channelId = 0;
        while (channelId < waveNumChannels) {
          writer.writeInt16(convertFloatToInt(this.audioSequences[channelId].data[i], waveBitsPerSample, signedBorder));
          ++channelId;
        }
        ++i;
      }
      return writer.data;
    };

    return WaveTrack;

  })();

  this.waveTrack = null;

  this.onmessage = function(event) {
    var channelData, encodedWave, fromIdx, toIdx;
    channelData = event.data;
    fromIdx = channelData.fromIdx;
    toIdx = channelData.toIdx;
    channelData.data = channelData.data.slice(fromIdx, toIdx);
    if (!this.waveTrack) {
      this.waveTrack = new WaveTrack();
    }
    this.waveTrack.fromAudioSequences(channelData);
    if (this.waveTrack.audioSequences.length >= 2) {
      encodedWave = this.waveTrack.encodeWaveFile();
      return this.postMessage(encodedWave);
    }
  };

}).call(this);
