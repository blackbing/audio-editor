// Generated by CoffeeScript 1.3.3
(function() {

  define(function(require) {
    var BinaryReader, BinaryWriter, BlobBuilder, Complex, FFTComplex, URL, WaveTrack, log, printComplexArray;
    log = require('lib/htc-log');
    BinaryWriter = require('../binary-writer');
    BinaryReader = require('../binary-reader');
    BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder;
    URL = window.URL || window.webkitURL;
    WaveTrack = (function() {
      var convertFloatToInt, convertIntToFloat, signedBorders;

      function WaveTrack() {}

      convertIntToFloat = function(value, waveBitsPerSample, signedBorder) {
        if (waveBitsPerSample === 8) {
          if (value === 0) {
            return -1.0;
          } else {
            return value / signedBorder - 1.0;
          }
        } else {
          if (value === 0) {
            return 0;
          } else {
            return value / signedBorder;
          }
        }
      };

      convertFloatToInt = function(value, waveBitsPerSample, signedBorder) {
        if (waveBitsPerSample === 8) {
          return (value + 1.0) * signedBorder;
        } else {
          return value * signedBorder;
        }
      };

      WaveTrack.sampleRate = 0;

      WaveTrack.audioSequences = [];

      signedBorders = [0, 0xFF - 0x80, 0xFFFF - 0x8000, 0xFFFFFFFFF - 0x80000000];

      WaveTrack.prototype.fromAudioSequences = function(sequences) {
        var i, lengthCheck, sampleRateCheck;
        if (sequences.length === 0) {
          return;
        }
        sampleRateCheck = sequences[0].sampleRate;
        lengthCheck = sequences[0].data.length;
        i = 1;
        while (i < sequences.length) {
          if (sequences[i].sampleRate !== sampleRateCheck || sequences[i].data.length !== lengthCheck) {
            throw "The input sequences must have the same length and samplerate";
          }
          ++i;
        }
        this.sampleRate = sampleRateCheck;
        this.audioSequences = sequences;
        return null;
      };

      WaveTrack.prototype.toBlobURL = function(mimeType) {
        var blob, encodedWave;
        encodedWave = this.encodeWaveFile();
        /*
              bb = new BlobBuilder()
              blob = undefined
              bb.append encodedWave.buffer
              blob = bb.getBlob(mimeType)
        */

        blob = new Blob([encodedWave.buffer], {
          type: mimeType
        });
        return URL.createObjectURL(blob);
      };

      WaveTrack.prototype.toDataURL = function() {
        return '';
      };

      WaveTrack.prototype.decodeWaveFile = function(data) {
        var channelId, channelNames, floatValue, i, reader, samplesPerChannel, signBorderId, signedBorder, value, waveAudioFormat, waveBitsPerSample, waveBlockAlign, waveByteRate, waveChunkID, waveChunkSize, waveFormat, waveNumChannels, waveSampleRate, waveSubchunk1ID, waveSubchunk1Size, waveSubchunk2ID, waveSubchunk2Size, _results;
        reader = new BinaryReader(data);
        waveChunkID = reader.readString(4);
        waveChunkSize = reader.readUInt32();
        waveFormat = reader.readString(4);
        reader.gotoString("fmt ");
        waveSubchunk1ID = reader.readString(4);
        waveSubchunk1Size = reader.readUInt32();
        waveAudioFormat = reader.readUInt16();
        waveNumChannels = this.channels = reader.readUInt16();
        waveSampleRate = this.sampleRate = reader.readUInt32();
        waveByteRate = reader.readUInt32();
        waveBlockAlign = reader.readUInt16();
        waveBitsPerSample = reader.readUInt16();
        reader.gotoString("data");
        waveSubchunk2ID = reader.readString(4);
        waveSubchunk2Size = reader.readUInt32();
        samplesPerChannel = this.samplesPerChannel = waveSubchunk2Size / waveBlockAlign;
        channelNames = ["Left Channel", "Right Channel"];
        i = 0;
        while (i < waveNumChannels) {
          this.audioSequences.push(new CreateNewAudioSequence(this.sampleRate));
          this.audioSequences[i].name = channelNames[i];
          ++i;
        }
        signBorderId = waveBitsPerSample / 8;
        signedBorder = signedBorders[signBorderId];
        this.gain = 0.0;
        i = 0;
        while (i < samplesPerChannel) {
          channelId = 0;
          while (channelId < waveNumChannels) {
            value = (waveBitsPerSample === 8 ? reader.readUInt8() : (waveBitsPerSample === 16 ? reader.readInt16() : reader.readInt32()));
            value = Math.min(1.0, Math.max(-1.0, value));
            floatValue = convertIntToFloat(value, waveBitsPerSample, signedBorder);
            this.audioSequences[channelId].data.push(floatValue);
            ++channelId;
          }
          ++i;
        }
        channelId = 0;
        _results = [];
        while (channelId < waveNumChannels) {
          this.audioSequences[channelId].gain = this.audioSequences[channelId].getGain();
          _results.push(++channelId);
        }
        return _results;
      };

      WaveTrack.prototype.encodeWaveFile = function() {
        var channelId, i, signBorderId, signedBorder, totalSize, waveAudioFormat, waveBitsPerSample, waveBlockAlign, waveByteRate, waveChunkID, waveChunkSize, waveFormat, waveNumChannels, waveSampleRate, waveSamplesPerChannel, waveSubchunk1ID, waveSubchunk1Size, waveSubchunk2ID, waveSubchunk2Size, writer;
        waveChunkID = "RIFF";
        waveFormat = "WAVE";
        waveSubchunk1ID = "fmt ";
        waveSubchunk1Size = 16;
        waveAudioFormat = 1;
        waveNumChannels = this.audioSequences.length;
        waveSampleRate = this.sampleRate;
        waveBitsPerSample = 16;
        waveByteRate = waveSampleRate * waveNumChannels * waveBitsPerSample / 8;
        waveBlockAlign = waveNumChannels * waveBitsPerSample / 8;
        waveBitsPerSample = 16;
        waveSamplesPerChannel = this.audioSequences[0].data.length;
        waveSubchunk2ID = "data";
        waveSubchunk2Size = waveSamplesPerChannel * waveBlockAlign;
        waveChunkSize = waveSubchunk2Size + 36;
        totalSize = waveChunkSize + 8;
        writer = new BinaryWriter(totalSize);
        writer.writeString(waveChunkID);
        writer.writeUInt32(waveChunkSize);
        writer.writeString(waveFormat);
        writer.writeString(waveSubchunk1ID);
        writer.writeUInt32(waveSubchunk1Size);
        writer.writeUInt16(waveAudioFormat);
        writer.writeUInt16(waveNumChannels);
        writer.writeUInt32(waveSampleRate);
        writer.writeUInt32(waveByteRate);
        writer.writeUInt16(waveBlockAlign);
        writer.writeUInt16(waveBitsPerSample);
        writer.writeString(waveSubchunk2ID);
        writer.writeUInt32(waveSubchunk2Size);
        signBorderId = waveBitsPerSample / 8;
        signedBorder = signedBorders[signBorderId];
        i = 0;
        while (i < waveSamplesPerChannel) {
          channelId = 0;
          while (channelId < waveNumChannels) {
            writer.writeInt16(convertFloatToInt(this.audioSequences[channelId].data[i], waveBitsPerSample, signedBorder));
            ++channelId;
          }
          ++i;
        }
        return writer.data;
      };

      return WaveTrack;

    })();
    Complex = function(real, img) {
      var conjugate, minus, plus, print, times, timesScalar;
      this.real = real;
      this.img = img;
      this.plus = plus = function(c) {
        return new Complex(this.real + c.real, this.img + c.img);
      };
      this.minus = minus = function(c) {
        return new Complex(this.real - c.real, this.img - c.img);
      };
      this.times = times = function(c) {
        return new Complex(this.real * c.real - this.img * c.img, this.real * c.img + this.img * c.real);
      };
      this.timesScalar = timesScalar = function(s) {
        return new Complex(this.real * s, this.img * s);
      };
      this.conjugate = conjugate = function() {
        return new Complex(this.real, -this.img);
      };
      return this.print = print = function() {
        var r;
        r = this.real;
        return "" + r + " " + this.img + "";
      };
    };
    printComplexArray = function(a) {
      var i;
      i = 0;
      while (i < a.length) {
        console.log(a[i].print() + "\n");
        ++i;
      }
      return console.log("===============");
    };
    FFTComplex = function() {
      var fft, ifft;
      this.fft = fft = function(arrayOfComplex) {
        var even, k, kth, len, odd, q, r, wk, y;
        len = arrayOfComplex.length;
        if (len === 1) {
          return [arrayOfComplex[0]];
        }
        if (len % 2 !== 0) {
          debugger;
        }
        even = [];
        k = 0;
        while (k < len / 2) {
          even.push(arrayOfComplex[k * 2]);
          ++k;
        }
        q = this.fft(even);
        odd = [];
        k = 0;
        while (k < len / 2) {
          odd.push(arrayOfComplex[k * 2 + 1]);
          ++k;
        }
        r = this.fft(odd);
        y = [];
        k = 0;
        while (k < len / 2) {
          kth = -2.0 * k * Math.PI / len;
          wk = new Complex(Math.cos(kth), Math.sin(kth));
          y[k] = q[k].plus(wk.times(r[k]));
          y[k + len / 2] = q[k].minus(wk.times(r[k]));
          ++k;
        }
        return y;
      };
      return this.ifft = ifft = function(arrayOfComplex) {
        var i, len, y;
        len = arrayOfComplex.length;
        y = [];
        i = 0;
        while (i < len) {
          y[i] = arrayOfComplex[i].conjugate();
          ++i;
        }
        y = this.fft(y);
        i = 0;
        while (i < len) {
          y[i] = y[i].conjugate();
          ++i;
        }
        i = 0;
        while (i < len) {
          y[i] = y[i].timesScalar(1.0 / len);
          ++i;
        }
        return y;
      };
    };
    return WaveTrack;
  });

}).call(this);
