// Generated by CoffeeScript 1.3.3
(function() {

  define(function(require) {
    var Drawer, exports;
    Drawer = {
      init: function(params) {
        this.canvas = params.canvas;
        this.cc = this.canvas.getContext("2d");
        this.width = this.canvas.width = params.width;
        this.height = this.canvas.height = params.height;
        if (params.color) {
          return this.cc.fillStyle = params.color;
        }
      },
      bindClick: function(callback) {
        var my;
        my = this;
        return this.canvas.addEventListener("click", (function(e) {
          var canvasPosition, percents, relX;
          canvasPosition = my.canvas.getBoundingClientRect();
          relX = e.pageX - canvasPosition.left;
          percents = relX / my.width;
          return callback(percents);
        }), false);
      },
      drawBuffer: function(buffer) {
        var c, chan, chan_sum, i, k, max, maxsum, scale, slice, sum;
        k = buffer.getChannelData(0).length / this.width;
        slice = Array.prototype.slice;
        maxsum = 0;
        i = 0;
        chan_sum = [];
        while (i < this.width) {
          sum = 0;
          c = 0;
          while (c < buffer.numberOfChannels) {
            chan = buffer.getChannelData(c);
            max = Math.max.apply(Math, slice.call(chan, i * k, (i + 1) * k));
            sum += max;
            c++;
          }
          chan_sum.push(sum);
          if (sum > maxsum) {
            maxsum = sum;
          }
          i++;
        }
        scale = 1 / maxsum;
        /*
              i = 0
              while i < @width
                sum = 0
                c = 0
        
                while c < buffer.numberOfChannels
                  chan = buffer.getChannelData(c)
                  max = Math.max.apply(Math, slice.call(chan, i * k, (i + 1) * k))
                  sum += max
                  c++
                sum *= scale
                @drawFrame sum, i
                i++
        */

        for (i in chan_sum) {
          this.drawFrame(chan_sum[i], i);
        }
        chan_sum = null;
        return this.framesPerPx = k;
      },
      drawFrame: function(value, index) {
        var h, w, x, y;
        w = 1;
        h = Math.round(value * this.height);
        x = index;
        y = Math.round((this.height - h) / 2);
        return this.cc.fillRect(x, y, w, h);
      }
      /*
          drawCursor: ->
            @cursor.style.left = @cursorPos + "px"  if @cursor
      
          setCursorPercent: (percents) ->
            pos = Math.round(@width * percents)
            @updateCursor pos  if @cursorPos isnt pos
      
          updateCursor: (pos) ->
            @cursorPos = pos
            @framePos = pos * @framesPerPx
            @drawCursor()
      */

    };
    return exports = Drawer;
  });

}).call(this);
